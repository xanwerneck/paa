\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{float}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algpseudocode}

\setcounter{section}{-1}

\DeclareGraphicsExtensions{.eps}

\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

\algtext*{EndFor}
\algtext*{EndIf}
\algtext*{EndWhile}
\algtext*{EndFunction}
\algrenewcommand{\algorithmiccomment}[1]{// #1}
\newcommand{\algsection}[2]{(linha \ref{alg:#1:#2:start} à \ref{alg:#1:#2:end})}

\title{Projeto e Análise de Algoritmos\\Relatório -- Trabalho de Implementação}
\author{Alexandre Werneck\\Gabriel de Quadros Ligneul}
\date{12 de Dezembro de 2016}

\begin{document}

\maketitle

%-------------------------------------------------------------------------------
\section{Introdução}

Esta seção apresenta as conveções e estruturas de dados utilizadas nos pseudocódigos deste trabalho. Descrevemos também a metodologia utilizada nos testes de desempenho.

Para representar os itens que fazem parte da entrada do problema, utilizamos uma estrutura de dados com peso, valor e lista de conflitos. A escrita e o acesso a cada campo dessa estrutura é feita em tempo constante. As estruturas de listas apresentadas nos algoritmos são implementadas como \emph{arrays} e possuem tempo de acesso constante.

Todos os testes de desempenho foram feitos no mesmo computador, que possui um processador Intel Core i7-4770 e sistema operacional Linux. Medimos o tempo real (\emph{wall-clock time}) usando o programa \texttt{time}. Para cada instancia do problema, foram realizados 10 medições e apenas o menor tempo foi considerado.

%-------------------------------------------------------------------------------
\section{Problema da Mochila com Frações}

\subsection{Pseudocódigo}

Propomos o algoritmo \ref{alg:q1} para obter a solução ótima para este problema

\begin{algorithm}[H]
\begin{algorithmic}[1]
  \Function{FractionalKnapsack}{$itens, n, W$}
    \For{$i \gets 1, n$}
      \State {$itens[i].ratio \gets itens[i].weight / itens[i].value$}
    \EndFor
    \State {Order $itens$ using the $ratio$ field}
    \State $selected \gets EmptyList()$
    \State $w \gets 0$
    \For{$i \gets 1, n$}
      \If{$w \ge W$}
        \State \textbf{break}
      \ElsIf{$w + itens[i].weight \le W$}
        \State $frac \gets 1$
      \Else
        \State $frac \gets (W - w) / item[i].weight$
      \EndIf
      \State $selected.append(\{i, frac\})$
    \EndFor
    \State \Return selected
  \EndFunction
\end{algorithmic}
\caption{Resolução do problema da mochila com frações.}
\label{alg:q1}
\end{algorithm}

\subsubsection{Prova que o Algoritmo é Ótimo}

TODO.

\subsection{Avaliação da Complexidade}

TODO.

\subsection{Testes de Desempenho}

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c}
Número de itens & W=1000 & W=2000 & W=5000 & W=10000 \\
\hline
120 & 0.022 & 0.022 & 0.021 & 0.021 \\
250 & 0.025 & 0.026 & 0.026 & 0.027 \\
500 & 0.042 & 0.041 & 0.042 & 0.041 \\
1000 & 0.104 & 0.102 & 0.104 & 0.104 \\
\end{tabular}
\caption{Medida do tempo de execução (em segundos) implementação da questão 1 para as instâncias disponibilizados.}
\label{tab:q1:bench}
\end{table}

%-------------------------------------------------------------------------------
\section{Problema da Mochila com Inteiros}

\subsection{Contraexemplo para o Algoritmo Guloso}

O algoritmo da questão anterior não retorna a solução ótima em todos os casos para esta versão do problema. Um contraexemplo é uma instância com dois itens: o item 1 com peso 10kg e valor \$10 e o item 2 com peso 1kg e valor \$2. Numa mochila que aguenta 10kg, o algoritmo anterior escolheria primeiro o item 2, pois ele tem a maior razão entre valor e peso. Não seria possível inserir o item 1 no conjunto final da solução, pois ultrapassaria o limite da mochila, e consequentemente o lucro seria \$2. Entretanto, a solução ótima para essa instância do problema contém apenas o item 1, possibilitando \$10 de lucro.

\subsection{Algoritmo Ótimo}

Propomos o algoritmo \ref{alg:q2}, que utiliza programação dinâmica, para obter a solução ótima para este problema.

\begin{algorithm}[H]
\begin{algorithmic}[1]
  \Function{IntegerKnapsack}{$itens, n, W$}
    \State \Comment{Initialization:} \label{alg:q2:init:start}
    \State $M \gets ZeroedMatrix(n, W)$ \Comment{Optimum profit}
    \State $S \gets ZeroedMatrix(n, W)$ \Comment{Selected itens} \label{alg:q2:init:end}
    \State \Comment{Find the best solution for each subproblem:} \label{alg:q2:calcopt:start}
    \For{$i \gets 1, n$}
      \For{$w \gets 1, W$}
        \State $li \gets M[i - 1, w]$ \Comment{Best solution for last item}
        \If{$itens[i].weight > w$}
          \State $M[i, w] \gets li$
        \Else
          \State \Comment{$ti$ is the best solution with this item:}
          \State $ti \gets itens[i].value + M[i- 1, w - itens[i].weight]$
          \If{ti > li}
            \State $M[i, w] \gets ti$
            \State $S[i, w] \gets 1$ \Comment{Use this item in the solution}
          \Else
            \State $M[i, w] \gets li$
          \EndIf
        \EndIf
      \EndFor
    \EndFor \label{alg:q2:calcopt:end}
    \State \Comment{Build the list of selected itens:} \label{alg:q2:select:start}
    \State $selected \gets EmptyList()$
    \State $w \gets M[n, W]$
    \For{$i \gets n, 1$}
      \If{$S[i, w] == 1$}
        \State $selected.append(i)$
        \State $w \gets w - itens[i].weight$
      \EndIf
    \EndFor
    \State \Return selected \label{alg:q2:select:end}
  \EndFunction
\end{algorithmic}
\caption{Resolução do problema da mochila com valores inteiros.}
\label{alg:q2}
\end{algorithm}

\subsubsection{Avaliação da Complexidade}

O primeiro trexo do algoritmo \algsection{q2}{init} cria duas matrizes de tamanho $n \times W$, percorre todas as suas posições e as inicializa com 0. Entretanto, como o tamanho da matrix varia de acordo com o \emph{valor} de $W$, não podemos avaliar a complexidade como $\theta(nW)$. Definimos K como o tamanho (número de bits) de $W$ e sabemos que $W \approx 2^K$. Logo, levando em conta o \emph{tamanho} de $W$, a complexidade desse trecho é de $\theta(n2^K)$. O segundo trecho \algsection{q2}{calcopt} realiza uma sério de operações em tempo constante para cada posição da matrix $M$, logo a complexidade desse último também é $\theta(n2^K)$. Por fim, o terceiro trecho \algsection{q2}{select} percorre a lista de itens e insere (operação constante) os selecionadas na lista de saída. No pior caso, todos os itens são seleciodados e toda a lista de entrada é percorrida, logo avaliamos a complexidade como $\theta(n)$. A complexidade da função é a soma da complexidade dos três trechos: $T(n, K) \in \theta(n2^K + n2^K + n) \in \theta(n2^K)$.

\subsection{Avaliação do Desempenho}

A tabela \ref{tab:q2:bench} apresenta o tempo de execução do programa implementado para as instâncias providas.
Com base no gráfico da esqueda na figura \ref{fig:q2:itens}, podemos confirmar que o tempo de execução cresce linearmente em relação ao número de itens. Com base no gráfico da direita, observamos que o tempo de execução cresce linearmente em relação ao peso aceito pela mochila. Consequentemente, o tempo de execução cresce exponencialmente em relação ao tamanho (número de bits) desse peso.

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c}
Número de itens & W=1000 & W=2000 & W=5000 & W=10000 \\
\hline
120 & 0.072 & 0.126 & 0.306 & 0.599 \\
250 & 0.128 & 0.243 & 0.593 & 1.208 \\
500 & 0.259 & 0.498 & 1.218 & 2.436 \\
1000 & 0.555 & 1.038 & 2.515 & 5.054 \\
\end{tabular}
\caption{Medida do tempo de execução (em segundos) implementação da questão 2 para as instâncias disponibilizados.}
\label{tab:q2:bench}
\end{table}

\begin{figure}[H]
\centering
\includegraphics[width=0.49\linewidth]{plots/q2itens}
\includegraphics[width=0.49\linewidth]{plots/q2weight}
\caption{Variação do tempo de execução de acordo com o número de itens e com o peso aceito pela mochila.}
\label{fig:q2:itens}
\end{figure}

%-------------------------------------------------------------------------------
\section{Problema da Mochila com Conflitos}

\subsection{Algoritmo Proposto}

Para esta versão do problema da mochila propomos quatro diferentes heurísticas, apresentadas na tabela \ref{tab:q3:heuristics}. O algoritmo \ref{alg:q3} gera um conjunto de itens para cada heurística e escolhe o de maior lucro.

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{2.5}
\begin{tabular}{c|c}
Heurística & Fórmula \\\hline
H1 & $\dfrac{peso}{valor}$ \\
H2 & $\dfrac{1}{valor}$ \\
H3 & $\sum^{conflitos}_{c} c.valor$ \\
H4 & $\dfrac{1}{\sum^{conflitos}_{c}\dfrac{c.peso}{c.valor}}$ \\
\end{tabular}
\caption{Heurísticas utilizadas para resolver o problema da mochila com conflitos.}
\label{tab:q3:heuristics}
\end{table}

\begin{algorithm}[H]
\begin{algorithmic}[1]
  \State \Comment{Obtains the group of itens using the heuristic H:}
  \Function{ConflictsKnapsackHelper}{$itens, n, W, H$}
    \For{$i \gets 1, n$} \label{alg:q3:heuristics:start}
      \State {$itens[i].heuristic \gets H(itens[i])$}
    \EndFor \label{alg:q3:heuristics:end}
    \State {Order $itens$ using the $heuristic$ field} \label{alg:q3:sort}
    \State $hasconflict \gets EmptyList()$ \label{alg:q3:init:start}
    \For{$i \gets 1, n$}
      \State $hasconflict[i] \gets False$
    \EndFor
    \State $selected \gets EmptyList()$
    \State $w \gets 0$ \label{alg:q3:init:end}
    \For{$i \gets 1, n$} \label{alg:q3:select:start}
      \If{$!hasconflict[itens[i].index] \textrm{ \textbf{and} } itens[i].weight + w \le W$}
        \State $selected.append(i)$
        \For{$c \textrm{ \textbf{in} } itens[i].conflicts$}
          \State $hasconflict[c.index] \gets True$
        \EndFor
      \EndIf
    \EndFor \label{alg:q3:select:end}
    \State \Return selected
  \EndFunction
  \State \Comment{Return the most valuable set of itens given the heuristics:}
  \Function{ConflictsKnapsack}{$itens, n, W$}
    \State $bestsack \gets Nil$
    \State $bestvalue \gets 0$
    \For{$H \textrm{ \textbf{in} } heuristics$}
      \State $sack \gets ConflictsKnapsackHelper(itens, n, W, H)$
      \State $value \gets ComputeSackValue(sack)$ \label{alg:q3:sackval}
      \If{$value \ge bestvalue$}
        \State $bestsack \gets sack$
        \State $bestvalue \gets value$
      \EndIf
    \EndFor
    \State \Return $bestsack$
  \EndFunction
\end{algorithmic}
\caption{Resolução do problema da mochila com conflitos.}
\label{alg:q3}
\end{algorithm}

\subsection{Avaliação da Complexidade}

Definimos $T_h(n)$ como a complexidade da função auxiliar \emph{ConflictsKnapsackHelper}. A complexidade para o cálculo da heurística \algsection{q3}{heuristics} é feito em $\theta(n)$ para H1 e H2, pois para cada item são apenas feitas operações constantes. Já para as heurísticas H3 e H4, são realizadas uma série de operações para cada conflito de cada item. Dessa forma, sabemos que a complexidade desse trecho é $\theta(\sum_{i}^{itens}|i.conflicts|) \in \theta(n + m)$, onde m é o número total de conflitos. A linha \ref{alg:q3:sort} realiza a ordenação da lista de itens, que pode ser feita em $\theta(nlogn)$. Em seguida, é trivial observar que as estruturas auxiliares \algsection{q3}{init} são inicializadas em tempo linear em relação ao número de itens. Por fim \algsection{q3}{select}, a lista de itens e os conflitos de cada um são percorridos, logo a complexidade é $\theta(n + m)$. Somando a complexidade de todos os trechos da função, obtemos $T_h(n) \in \theta(nlogn + n + m) \in \theta(nlogn + m)$.

A função \emph{ConflictsKnapsack} apenas chama a função \emph{ConflictsKnapsackHelper} 4 vezes e seleciona qual conjunto de itens provém o maior lucro. Na linha \ref{alg:q3:sackval}, o lucro do conjunto de itens resultante é calculado em tempo linear em relação ao número de itens da entrada. Logo, a complexidade da função \emph{ConflictsKnapsack} é $T(n) \in \theta(4(n + T_h(n))) \in \theta(4(n + nlogn + m)) \in \theta(nlogn + m)$.

\subsection{Avaliação do Desempenho}

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c}
Número de itens & W=1000 & W=2000 & W=5000 & W=10000 \\
\hline
120 & 0.023	& 0.023	& 0.023	& 0.023	\\
250 & 0.035	& 0.036	& 0.035	& 0.036	\\
500 & 0.084	& 0.086	& 0.084	& 0.085	\\
1000 & 0.344	& 0.347	& 0.343	& 0.345	\\
\end{tabular}
\caption{Medida do tempo de execução (em segundos) implementação da questão 3 para as instâncias disponibilizados.}
\label{tab:q3:bench}
\end{table}

\end{document}

