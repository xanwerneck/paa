\documentclass[a4paper, 11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{float}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algpseudocode}

\setcounter{section}{-1}

\DeclareGraphicsExtensions{.eps}

\makeatletter
\renewcommand{\ALG@name}{Algoritmo}
\makeatother

\title{Relatório -- Implementation Work}
\author{Alexandre Werneck\\Gabriel de Quadros Ligneul}
\date{12 de Dezembro de 2016}

\begin{document}

\maketitle

%-------------------------------------------------------------------------------
\section{Introdução}

TODO.

%-------------------------------------------------------------------------------
\section{On the Fractional Knapsack Problem}

\subsection{Pseudocódigo}

TODO.

\subsubsection{Prova que o Algoritmo é Ótimo}

TODO.

\subsection{Avaliação da Complexidade}

TODO.

\subsection{Testes de Desempenho}

%-------------------------------------------------------------------------------
\section{Moving on Towards Integer Optimization}

\subsection{Item 1}

O algoritmo da questão anterior não retorna a solução ótima em todos os casos. Um contraexemplo é uma instância do problema com dois itens: o item 1 com peso 10kg e valor \$10 e o item 2 com peso 1kg e valor \$2. Numa mochila que aguenta 10kg, o algoritmo anterior escolheria primeiro o item 2, pois ele tem a maior razão entre valor e peso. Não seria possível inserir o item 1 no conjunto final da solução, pois ultrapassaria o limite da mochila, e consequentemente o lucro seria \$2. Entretanto, a solução ótima para essa instância do problema contém apenas o item 1, possibilitando \$10 de lucro.

\subsection{Item 2}

\iffalse
If the greedy algorithm does not guarantee optimality, provide an alternative optimal
algorithm and analyze its computational complexity.
\fi

Propomos o algoritmo \ref{alg:q2} como solução ótima para este problema. Neste algoritmo 

\begin{algorithm}
\begin{algorithmic}
  \algrenewcommand{\algorithmiccomment}[1]{\hskip3em\# #1}
  \Function{Knapsack}{$itens, n, W$} \Comment{Itens are indexed from 1 to n}
    \State \# Initialization:
    \State $M \gets ZeroedMatrix(n, W)$ \Comment{Optimum profit}
    \State $S \gets ZeroedMatrix(n, W)$ \Comment{Selected itens}
    \State \# Find the best solution for each subproblem:
    \For{$i \gets 1, n$}
      \For{$w \gets 1, W$}
        \State $li = M[i - 1, w]$ \Comment{Best solution for last item}
        \If{$itens[i].w > w$}
          \State $M[i, w] = li$
        \Else
          \State $ti = itens[i].v + M[i- 1, w - itens[i].w]$
          \If{ti > li}
            \State $M[i, w] = ti$
            \State $S[i, w] = 1$ \Comment{Use this item}
          \Else
            \State $M[i, w] = li$
          \EndIf
        \EndIf
      \EndFor
    \EndFor
    \State \# Build the list of selected itens:
    \State $selected \gets EmptyList()$
    \State $w = M[n, W]$
    \For{$i \gets n, 1$}
      \If{$S[i, w] == 1$}
        \State $selected.append(i)$
        \State $w = w - itens[i].w$
      \EndIf
    \EndFor
  \EndFunction
\end{algorithmic}

\iffalse
 \And ti > li$}
function integer_knapsack(itens, n, W)
  for i in range(1, n + 1): # O(nW)
    for w in range(W + 1):
      item_w = itens[i - 1].weight
      item_v = itens[i - 1].value
      sack_with_last_item = sack_value[i - 1][w]
      if item_w > w:
        sack_value[i][w] = sack_with_last_item
      else:
        sack_with_this_item = sack_value[i - 1][w - item_w] + item_v
        if sack_with_this_item > sack_with_last_item:
          sack_value[i][w] = sack_with_this_item
          sack_itens[i][w] = True
        else:
          sack_value[i][w] = sack_with_last_item
  selected_itens = []
  curr_w = W
  for i in reversed(range(1, n + 1)): # O(n)
    item = itens[i - 1]
    if sack_itens[i][curr_w]:
      curr_w -= item.weight
      selected_itens.append(SelectedItem(item, 1))
  return selected_itens
\fi

\caption{Resolução do problema da mochila inteiro.}
\label{alg:q2}
\end{algorithm}

%-------------------------------------------------------------------------------
\section{Adding Some Spice to the Problem}

\iffalse
Implement the proposed algorithm, and verify if its theoretical complexity is attained, in
practice, on the benchmark instances provided with the project.
\fi

A tabela \ref{tab:benchq2} apresenta o tempo de execução do programa implementado para os diferentes parâmetros de entrada.

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c}
Número de itens & W=1000 & W=2000 & W=5000 & W=10000 \\
\hline
120 & 0.134 & 0.248 & 0.592 & 1.207 \\
250 & 0.253 & 0.488 & 1.191 & 2.447 \\
500 & 0.528 & 1.022 & 2.524 & 5.034 \\
1000 & 1.136 & 2.141 & 5.217 & 10.396 \\
\end{tabular}
\caption{Medida do tempo de execução (em segundos) do programa implementado para questão 2 para os benchmarks disponibilizados.}
\label{tab:benchq2}
\end{table}

\end{document}

